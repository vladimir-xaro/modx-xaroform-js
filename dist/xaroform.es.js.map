{"version":3,"file":"xaroform.es.js","sources":["../src/Validator.ts","../src/helpers.ts","../src/Field.ts","../src/Form.ts"],"sourcesContent":["import { Field as I_Field } from \"./types\";\n\nexport default class Validator {\n  public static required(field: I_Field) : boolean {\n    if (field.isMultiple) {\n      return !!(field.value as FormDataEntryValue[]).length;\n    } else if (field.isFile) {\n      for (const input of field.inputs) {\n        if (input.value !== '') {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return field.value !== null && field.value !== '';\n    // return field.isMultiple ? !!(field.value as FormDataEntryValue[]).length : field.value !== '';\n  }\n\n  public static minLength(field: I_Field, value: string) : boolean {\n    return (field.value as string).length >= +value;\n  }\n\n  public static maxLength(field: I_Field, value: string) : boolean {\n    return (field.value as string).length <= +value;\n  }\n\n  public static email(field: I_Field) : boolean {\n    return !!(field.value as string).match(/^[a-zA-Zа-яА-Яё\\d][a-zA-Zа-яА-ЯёЁ\\d\\.\\-_]*[a-zA-Zа-яА-ЯёЁ\\d]\\@[a-zA-Zа-яА-ЯёЁ\\d]([a-zA-Zа-яА-ЯёЁ\\d\\-]|\\.)+[a-zA-Zа-яА-ЯёЁ\\d]{2,}$/);\n  }\n\n  public static passwordConfirm(field: I_Field, confirm_key: string) : boolean {\n    return field.value === field.form.fields[confirm_key].value;\n  }\n\n  // public static file\n}","export const microtime = (getAsFloat: boolean = true) => {\n  let s, now, multiplier;\n\n  if (typeof performance !== 'undefined' && performance.now) {\n    now = (performance.now() + performance.timing.navigationStart) / 1000;\n    multiplier = 1e6; // 1,000,000 for microseconds\n  } else {\n    now = (Date.now ? Date.now() : new Date().getTime()) / 1000;\n    multiplier = 1e3; // 1,000\n  }\n\n  // Getting microtime as a float is easy\n  if (getAsFloat) {\n    return now;\n  }\n\n  // Dirty trick to only get the integer part\n  s = now | 0;\n\n  return (Math.round((now - s) * multiplier ) / multiplier ) + ' ' + s;\n}\n\n/**\n * Convert string with camelCase to snake_case\n * @param str string\n * @returns string\n * @example camelToSnake('isNumber') => 'is_number'\n */\nexport const camelToSnake = (str: string) => str.replace(/[A-Z]/g, (char: string) => '_' + char.toLowerCase());\n\n/**\n * Convert string with snake_case to camelCase\n * @param str string\n * @returns string\n * @example snakeToCamel('is_number') => 'isNumber'\n */\nexport const snakeToCamel = (str: string) => str.replace(/_[a-z]/g, (char: string) => char.toUpperCase().replace('_', ''));\n\n/**\n * Returns the intersection of two arrays.\n * @example intersection([ 1, 3, 5 ], [ 1, 5, 7 ]) => [ 1, 5 ]\n */\nexport const intersection = (first: any[], second: any[]) =>\n  first.filter((x: any) => second.includes(x));\n\n/**\n * Returns the intersection of multiple arrays.\n * @param arrs any[][]\n * @returns any[]\n * @example intersectionMultiple([ 1, 3, 5 ]) => [ 1, 3, 5 ]\n * @example intersectionMultiple([ 1, 3, 5 ], [ 1, 5, 7 ]) => [ 1, 5 ]\n * @example intersectionMultiple([ 1, 3, 5 ], [ 1, 5, 7 ], [ 1, 7, 11 ]) => [ 1 ]\n */\nexport const intersectionMultiple = (...arrs: any[][]) => {\n  if (!arrs.length) {\n    return [];\n  }\n\n  if (arrs.length === 1) {\n    return arrs[0];\n  }\n\n  let result!: any[];\n\n  for (let i = 1; i < arrs.length; i++) {\n    result = arrs[i-1].filter(x => arrs[i].includes(x));\n  }\n\n  return result;\n}\n\n// console.log(intersectionMultiple(\n//   [ 1, 3, 5, 7, 9, 11, 13],\n//   [ 2, 3, 7, 11, 15],\n//   // [ 5, 7, 10, 11, 17 ],\n//   // [ 4, 6, 7, 11 ]\n// ));\n/**\n * Returns the difference between the second array and the first\n * @example difference([ 1, 3, 5 ], [ 1, 5, 9 ]) => [ 3 ];\n * @example difference([ 1, 5, 9 ], [ 1, 3, 5 ]) => [ 9 ];\n */\nexport const difference = (target: any[], compare: any[]) =>\n  compare.filter((x: any) => !target.includes(x));\n\n/**\n * Returns the difference of two arrays.\n * @example difference([ 1, 3, 5 ], [ 1, 5, 9 ]) => [ 3, 9 ];\n */\nexport const differenceBoth = (first: any[], second: any[]) =>\n  first.filter((x: any) => !second.includes(x))\n  .concat(second.filter((x: any) => !first.includes(x)));\n\n/**\n * Alias for Object.keys()\n * @param obj Object\n * @returns string[]\n */\nexport const keys: (obj: {}) => string[] = obj => Object.keys(obj);","import {\n  Field         as I_Field,\n  FieldCtorCfg  as I_FieldConstructorConfig,\n  Form          as I_XaroForm,\n  Error         as I_Error,\n  InputElement  as I_InputElement\n} from \"./types\";\nimport $, { MicroDOM, nextTick } from \"@xaro/micro-dom\";\nimport { keys } from \"./helpers\";\n\nexport default class Field implements I_Field {\n  form:           I_XaroForm;\n  el:             HTMLElement;\n  errorsWrapper?: HTMLElement\n  inputs:         MicroDOM<I_InputElement>;\n  subInputs?:     MicroDOM<HTMLOptionElement>;\n  errors:       {\n    [code: string]: {\n      msg: string;\n      el?: HTMLElement;\n    }\n  } = {};\n  type:           string;\n  name:           string;\n  isMultiple:     boolean;\n  isFile:         boolean;\n\n  constructor(config: I_FieldConstructorConfig) {\n    this.form           = config.form;\n    this.el             = config.el;\n    this.errorsWrapper  = this.el.querySelector<HTMLElement>('.x-form__field-errors') || undefined;\n    this.inputs         = config.inputs;\n    this.name           = config.name;\n    this.type           = config.type;\n\n    this.isMultiple = this.name.includes('[]');\n    this.isFile     = this.type === 'file';\n  }\n\n  get value(): FormDataEntryValue | FormDataEntryValue[] | null {\n    const data = new FormData(this.form.config.el);\n\n    return this.isMultiple ? data.getAll(this.name) : data.get(this.name);\n  }\n\n  public clearValue(): void {\n    if (this.isMultiple) {\n      this.inputs.forEach(input => (input as HTMLInputElement).checked = false);\n    } else {\n      this.inputs.forEach(input => input.value = '');\n    }\n  }\n\n  public addError(code: string|number, msg: string, el?: HTMLElement): void {\n    this.el.classList.add('x-form__field--error');\n\n    if (! keys(this.errors).includes('' + code)) {\n      if (! el) {\n        const $el = $().create<HTMLElement>({ content: msg }).addClass('x-form__field-error');\n        el = $el[0];\n      }\n\n      this.errors[code] = {\n        msg,\n        el\n      };\n      \n      (this.errorsWrapper || this.el).append(this.errors[code].el!);\n      nextTick(() => el!.classList.add('x-form__field-error--show'));\n    }\n  }\n\n  public removeError(code: string) : void {\n    if (keys(this.errors).includes(code)) {\n      this.errors[code].el?.remove();\n      delete this.errors[code];\n    }\n\n    if (! keys(this.errors).length) {\n      this.el.classList.remove('x-form__field--error');\n    }\n  }\n\n  public clearErrors() : void {\n    for (const error_code in this.errors) {\n      this.removeError(error_code);\n    }\n    this.el.classList.remove('x-form__field--error');\n  }\n}","import {\n  Form          as I_Form,\n  FormInitCfg   as I_FormInitCfg,\n  FormCtorCfg   as I_FormCtorCfg,\n  FormCfg       as I_FormCfg,\n  Field         as I_Field,\n  InputElement  as I_InputElement,\n  FormPlugin    as I_XaroFormPlugin,\n  FormCtor      as I_FormCtor\n} from './types';\nimport EventEmitter from '@xaro/event-emitter';\nimport $, { MicroDOM, nextTick } from '@xaro/micro-dom';\nimport { merge } from '@xaro/helpers';\nimport Validator from './Validator';\nimport Field from './Field';\nimport { camelToSnake, difference, intersection, keys, snakeToCamel } from './helpers';\n\nconst Form: I_FormCtor = class FormClass implements I_Form {\n  public static EventEmitter  = EventEmitter;\n  public static MicroDOM      = MicroDOM;\n\n  // object with all registered plugins\n  public static plugins: { [key: string]: I_XaroFormPlugin } = {};\n\n  // all forms instances\n  public static instances: { [key: string]: FormClass[] } = {};\n\n  // forms amount\n  public static numbers: number = 0;\n  \n  // common forms config\n  public static config: {\n    lexicon: { [key: string]: string };\n    [key: string]: any;\n  };\n\n  // custom validators\n  public static customValidators: { [key: string]: Function } = {};\n\n  // event emitter\n  public emitter: EventEmitter;\n\n  // current form config\n  public config: I_FormCfg;\n\n  // fields elements with inputs\n  public fields: { [key: string]: I_Field } = {};\n\n  // form buttons element (submit/reset/etc)\n  public btns: { [key: string]: Array<HTMLButtonElement | HTMLInputElement> } = {};\n\n  // other errors wrapper\n  public errorsEl?: HTMLElement;\n\n  // other errors object\n  public errors: {\n    [field_key: string]: {\n      [code: string]: {\n        msg: string,\n        el?: HTMLElement\n      }\n    }\n  } = {};\n\n  // plugins for current instance\n  public plugins: {\n    list:   string[],\n    config: {}\n  } = {\n    list:   [],\n    config: {}\n  };\n\n  /**\n   * Registers plugin for XaroForm\n   * @param name string Plugin's name\n   * @param plugin XaroFormPlugin Plugin's object\n   */\n  public static addPlugin(name: string, plugin: I_XaroFormPlugin): void {\n    FormClass.plugins[name] = plugin;\n  }\n\n  /**\n   * Removes plugin by name\n   * @param name string Plugin's name\n   */\n  public static removePlugin(name: string): void {\n    delete FormClass.plugins[name];\n  }\n\n  /**\n   * Initialize all forms from config\n   * @param config I_XaroFormInitializeConfig\n   */\n  public static initialize(config: I_FormInitCfg): void {\n    FormClass.config = config.common;\n\n    if ((window as any).XaroFormPlugins) {\n      for (const key in (window as any).XaroFormPlugins) {\n        FormClass.addPlugin(key, (window as any).XaroFormPlugins[key]);\n      }\n    }\n\n    for (const key in config.forms) {\n      FormClass.instances[key] = [];\n      const forms: MicroDOM<HTMLFormElement> = $(`${config.forms[key]['form_selector']}[data-form-key=\"${key}\"]`);\n      for (const el of forms) {\n        FormClass.instances[key].push(\n          new FormClass(merge(config.forms[key], {\n            el,\n            on: (window as any).XaroFormEvents || {}\n          }))\n        );\n        FormClass.numbers++;\n      }\n    }\n  }\n\n  constructor(config: I_FormCtorCfg) {\n    this.emitter = new EventEmitter(config.on);\n    this.config = config;\n\n    // Fields\n    for (const el of $(this.config.el).get<HTMLElement>('.x-form__field')) {\n      const inputs: MicroDOM<I_InputElement> = $(el).get<I_InputElement>('.x-form__input');\n\n      if (! inputs.length) {\n        throw new Error(\"Field element has not contains input element/s\");\n      }\n\n      const name: string = inputs[0].name;\n\n      if (! name) {\n        throw new Error(\"Name of input element does not exists\");\n      }\n\n      this.fields[name] = new Field({\n        form: this,\n        el,\n        inputs,\n        name,\n        type: inputs[0].type,\n      });\n    }\n\n    // Buttons (submit/reset/etc)\n    let btn_i = 0;\n    for (const btn of $(this.config.el).get<HTMLButtonElement|HTMLInputElement>('.x-form__btn')) {\n      const type: string|null = btn.getAttribute('type');\n      if (type) {\n        if (type in this.btns) {\n          this.btns[type].push(btn);\n        } else {\n          this.btns[type] = [ btn ];\n        }\n      } else {\n        this.btns['undefined_' + btn_i] = [ btn ];\n        btn_i++;\n      }\n    }\n    if (this.config.lockBtns) {\n      this.lockBtns();\n    }\n\n    // Common errors wrapper el\n    const errorsEl = $(this.config.el).get<HTMLElement>('.x-form__errors');\n    this.errorsEl = errorsEl.length ? errorsEl[0] : undefined;\n\n    // Submit listener\n    this.config.el.addEventListener('submit', e => {\n      e.preventDefault();\n\n      this.submit();\n\n      return false;\n    });\n\n\n    // plugins\n    const pluginKeys = keys(FormClass.plugins);\n    if (this.config.plugins) {\n      let plugins: string[] = [];\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        if (pluginKeys.includes(this.config.plugins[i])) {\n          plugins.push(this.config.plugins[i]);\n        }\n      }\n      this.plugins.list = plugins;\n    }\n\n    this.runPlugins('init', this);\n    this.emitter.emit('init', this);\n  }\n\n  public runPlugins(method: string, ...args): void {\n    for (const key of this.plugins.list) {\n      if (method in FormClass.plugins[key]) {\n        FormClass.plugins[key][method](this, ...args);\n      }\n    }\n  }\n\n  public validate() {\n    const rules = this.parseRules();\n\n    // codes\n    let codes: { [key: string]: { [method: string]: (string | number | boolean | undefined) } } = {};\n    for (const field in rules) {\n      for (const rule of rules[field]) {\n        const result = Validator[rule.method](this.fields[field], rule.value);\n        if (! result) {\n          if (! codes[field]) {\n            codes[field] = {};\n          }\n          codes[field][rule.method] = rule.value;\n        }\n      }\n    }\n\n    // get text error\n    let errors: { [key: string]: { [code: string]: string } } = {};\n    for (const field in codes) {\n      for (const code in codes[field]) {\n        const _code = camelToSnake(code);\n        const msg = this.config.lexicon && this.config.lexicon[_code]\n          ? this.config.lexicon.errors[_code]\n          : FormClass.config.lexicon.errors[_code];\n\n        if (typeof errors[field] === 'undefined') {\n          errors[field] = {};\n        }\n\n        errors[field][_code] = msg.replace('$', codes[field][code] as string || '');\n      }\n    }\n\n    return {\n      success: !keys(errors).length,\n      errors,\n    };\n  }\n\n  protected parseRules(): Object {\n    const validateProperty: string[] = this.config.client_validate.split(',');\n\n    let fields: { [key: string]: string[] } = {};\n    for (const item of validateProperty) {\n      let _item: string[] = item.split(':');\n      if (item.length) {\n        fields[_item.shift()!] = _item;\n      }\n    }\n\n    let fieldValidators: {\n      [key: string]: {\n        method: string,\n        value?: string | number | boolean\n      }[]\n    } = {};\n    for (const key in fields) {\n      for (const v of fields[key]) {\n        const _v: string[] = v.split('=');\n\n        // if (tmpValidatorMethods.indexOf(_v[0]) === -1) {\n        //   continue;\n        // }\n\n        if (typeof Validator[_v[0]] !== 'function') {\n          continue;\n        }\n\n        if (! Array.isArray(fieldValidators[key])) {\n          fieldValidators[key] = [];\n        }\n\n        fieldValidators[key].push({\n          method: _v.shift()!,\n          value:  _v.length ? _v[0].replace(/\\^+|\\^+/g, '') : undefined\n        })\n      }\n    }\n\n    return fieldValidators;\n  }\n\n  submit(): void {\n    this.lockBtns();\n\n    this.runPlugins('beforeSubmit', this);\n    this.emitter.emit('beforeSubmit', this);\n\n    const validator = this.validate();\n    \n    // clear fields errors\n    for (const field_key in this.fields) {\n      this.fields[field_key].clearErrors();\n    }\n\n    // clear other errors\n    this.clearErrors();\n\n    if (! validator.success) {\n      for (const field_key in validator.errors) {\n        for (const error_code in validator.errors[field_key]) {\n          this.fields[field_key].addError(error_code, validator.errors[field_key][error_code]);\n        }\n      }\n\n      this.unlockBtns();\n      // this, success, errors, side (client/server)\n      this.runPlugins('afterSubmit', this, validator.success, validator.errors, 'client');\n      this.emitter.emit('afterSubmit', this, validator.success, validator.errors, 'client');\n      return;\n    }\n\n    fetch(this.config['action_url'], {\n      method: 'POST',\n      // headers: {\n      //   'Content-Type': this.config.el.getAttribute('enctype')\n      // },\n      body: new FormData(this.config.el)\n    })\n    .then(response => {\n      // console.log(response.text());\n      return response.json();\n    })\n    .then(data => {\n      if (! data.success) {\n        // arrays of keys\n        const fields        = keys(this.fields);\n        const dataFields    = keys(data.errors);\n\n        // other errors\n        for (const key of difference(fields, dataFields)) {\n          for (const code in data.errors[key]) {\n            this.addError(key, code, data.errors[key][code]);\n          }\n        }\n\n        // fields errors\n        for (const key of intersection(dataFields, fields)) {\n          for (const code in data.errors[key]) {\n            this.fields[key].addError(code, data.errors[key][code]);\n          }\n        }\n      }\n      \n      this.runPlugins('afterSubmit', this, data.success, data.errors, 'server');\n      this.emitter.emit('afterSubmit', this, data.success, data.errors, 'server');\n    });\n  }\n\n  addError(key: string, code: string, msg: string, el?: HTMLElement): void {\n    if (keys(this.errors).includes(key) && keys(this.errors[key]).includes(code)) {\n      return;\n    }\n\n    this.errors[key] = this.errors[key] || {};\n    \n    if (this.errorsEl) {\n      if (! el) {\n        const $el = $().create<HTMLElement>({ content: msg }).addClass('x-form__error').attr({\n          'data-field-key':   key,\n          'data-error-code':  code,\n        });\n        \n        this.errorsEl.append($el[0]);\n        \n        nextTick(() => $el.addClass('x-form__error--show'));\n\n        el = $el[0];\n      }\n    }\n\n    this.errors[key][code] = {\n      msg,\n      el\n    }\n  }\n\n  removeError(key: string, code: string): void {\n    if (! keys(this.errors).includes(key) &&\n        ! keys(this.errors[key]).includes(code)) {\n      return;\n    }\n\n    this.errors[key][code].el?.remove();\n    delete this.errors[key][code];\n  }\n\n  clearErrors(): void {\n    // fields errors\n    for (const key in this.fields) {\n      this.fields[key].clearErrors();\n    }\n\n    // other errors\n    for (const key in this.errors) {\n      for (const code in this.errors[key]) {\n        this.removeError(key, code);\n      }\n    }\n  }\n\n  changeDisabledAttr(value: boolean): void {\n    for (const key in this.btns) {\n      for (const btn of this.btns[key]) {\n        btn.disabled = value;\n      }\n    }\n  }\n\n  lockBtns(): void {\n    this.changeDisabledAttr(true);\n  }\n\n  unlockBtns(): void {\n    this.changeDisabledAttr(false);\n  }\n\n  reset(): void {\n    this.config.el.reset();\n  }\n}\n\nexport default Form;"],"names":["Validator","[object Object]","field","isMultiple","value","length","isFile","input","inputs","match","confirm_key","form","fields","keys","obj","Object","Field","config","this","el","errorsWrapper","querySelector","undefined","name","type","includes","data","FormData","getAll","get","forEach","checked","code","msg","classList","add","errors","$el","$","create","content","addClass","append","nextTick","remove","error_code","removeError","Form","FormClass","list","emitter","EventEmitter","on","Error","btn_i","btn","getAttribute","btns","push","lockBtns","errorsEl","addEventListener","e","preventDefault","submit","pluginKeys","plugins","i","runPlugins","emit","plugin","common","window","XaroFormPlugins","key","addPlugin","forms","instances","merge","XaroFormEvents","numbers","method","args","rules","parseRules","codes","rule","_code","replace","char","toLowerCase","lexicon","success","validateProperty","client_validate","split","item","_item","shift","fieldValidators","v","_v","Array","isArray","validator","validate","field_key","clearErrors","addError","unlockBtns","fetch","body","then","response","json","dataFields","target","compare","filter","x","difference","first","second","intersection","attr","data-field-key","data-error-code","disabled","changeDisabledAttr","reset","_a","MicroDOM"],"mappings":"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"}