{"version":3,"file":"xaroform.js","sources":["../src/Validator.ts","../src/helpers.ts","../src/Field.ts","../src/XaroForm.ts"],"sourcesContent":["import { I_Field } from \"./types\";\n\nexport default class Validator {\n  public static required(field: I_Field) : boolean {\n    if (field.isMultiple) {\n      return !!(field.value as FormDataEntryValue[]).length;\n    } else if (field.isFile) {\n      for (const input of field.inputs) {\n        if (input.value !== '') {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return field.value !== null && field.value !== '';\n    // return field.isMultiple ? !!(field.value as FormDataEntryValue[]).length : field.value !== '';\n  }\n\n  public static minLength(field: I_Field, value: string) : boolean {\n    return (field.value as string).length >= +value;\n  }\n\n  public static maxLength(field: I_Field, value: string) : boolean {\n    return (field.value as string).length <= +value;\n  }\n\n  public static email(field: I_Field) : boolean {\n    return !!(field.value as string).match(/^[a-zA-Zа-яА-Яё\\d][a-zA-Zа-яА-ЯёЁ\\d\\.\\-_]*[a-zA-Zа-яА-ЯёЁ\\d]\\@[a-zA-Zа-яА-ЯёЁ\\d]([a-zA-Zа-яА-ЯёЁ\\d\\-]|\\.)+[a-zA-Zа-яА-ЯёЁ\\d]{2,}$/);\n  }\n\n  public static passwordConfirm(field: I_Field, confirm_key: string) : boolean {\n    return field.value === field.form.fields[confirm_key].value;\n  }\n\n  // public static file\n}","export const microtime = (getAsFloat: boolean = true) => {\n  let s, now, multiplier;\n\n  if (typeof performance !== 'undefined' && performance.now) {\n    now = (performance.now() + performance.timing.navigationStart) / 1000;\n    multiplier = 1e6; // 1,000,000 for microseconds\n  } else {\n    now = (Date.now ? Date.now() : new Date().getTime()) / 1000;\n    multiplier = 1e3; // 1,000\n  }\n\n  // Getting microtime as a float is easy\n  if (getAsFloat) {\n    return now;\n  }\n\n  // Dirty trick to only get the integer part\n  s = now | 0;\n\n  return (Math.round((now - s) * multiplier ) / multiplier ) + ' ' + s;\n}\n\n/**\n * Convert string with camelCase to snake_case\n * @param str string\n * @returns string\n * @example camelToSnake('isNumber') => 'is_number'\n */\nexport const camelToSnake = (str: string) => str.replace(/[A-Z]/g, (char: string) => '_' + char.toLowerCase());\n\n/**\n * Convert string with snake_case to camelCase\n * @param str string\n * @returns string\n * @example snakeToCamel('is_number') => 'isNumber'\n */\nexport const snakeToCamel = (str: string) => str.replace(/_[a-z]/g, (char: string) => char.toUpperCase().replace('_', ''));\n\n/**\n * Returns the intersection of two arrays.\n * @example intersection([ 1, 3, 5 ], [ 1, 5, 7 ]) => [ 1, 5 ]\n */\nexport const intersection = (first: any[], second: any[]) =>\n  first.filter((x: any) => second.includes(x));\n\n/**\n * Returns the intersection of multiple arrays.\n * @param arrs any[][]\n * @returns any[]\n * @example intersectionMultiple([ 1, 3, 5 ]) => [ 1, 3, 5 ]\n * @example intersectionMultiple([ 1, 3, 5 ], [ 1, 5, 7 ]) => [ 1, 5 ]\n * @example intersectionMultiple([ 1, 3, 5 ], [ 1, 5, 7 ], [ 1, 7, 11 ]) => [ 1 ]\n */\nexport const intersectionMultiple = (...arrs: any[][]) => {\n  if (!arrs.length) {\n    return [];\n  }\n\n  if (arrs.length === 1) {\n    return arrs[0];\n  }\n\n  let result!: any[];\n\n  for (let i = 1; i < arrs.length; i++) {\n    result = arrs[i-1].filter(x => arrs[i].includes(x));\n  }\n\n  return result;\n}\n\n// console.log(intersectionMultiple(\n//   [ 1, 3, 5, 7, 9, 11, 13],\n//   [ 2, 3, 7, 11, 15],\n//   // [ 5, 7, 10, 11, 17 ],\n//   // [ 4, 6, 7, 11 ]\n// ));\n/**\n * Returns the difference between the second array and the first\n * @example difference([ 1, 3, 5 ], [ 1, 5, 9 ]) => [ 3 ];\n * @example difference([ 1, 5, 9 ], [ 1, 3, 5 ]) => [ 9 ];\n */\nexport const difference = (target: any[], compare: any[]) =>\n  compare.filter((x: any) => !target.includes(x));\n\n/**\n * Returns the difference of two arrays.\n * @example difference([ 1, 3, 5 ], [ 1, 5, 9 ]) => [ 3, 9 ];\n */\nexport const differenceBoth = (first: any[], second: any[]) =>\n  first.filter((x: any) => !second.includes(x))\n  .concat(second.filter((x: any) => !first.includes(x)));\n\n/**\n * Alias for Object.keys()\n * @param obj Object\n * @returns string[]\n */\nexport const keys: (obj: {}) => string[] = obj => Object.keys(obj);","import { I_Field, I_FieldConstructorConfig, I_XaroForm, I_Error, InputElement } from \"./types\";\nimport $, { MicroDOM, nextTick } from \"@xaro/micro-dom\";\nimport { keys } from \"./helpers\";\n\nexport default class Field implements I_Field {\n  form:           I_XaroForm;\n  el:             HTMLElement;\n  errorsWrapper?: HTMLElement\n  inputs:         MicroDOM<InputElement>;\n  subInputs?:     MicroDOM<HTMLOptionElement>;\n  errors:       {\n    [code: string]: {\n      msg: string;\n      el?: HTMLElement;\n    }\n  } = {};\n  type:           string;\n  name:           string;\n  isMultiple:     boolean;\n  isFile:         boolean;\n\n  constructor(config: I_FieldConstructorConfig) {\n    this.form           = config.form;\n    this.el             = config.el;\n    this.errorsWrapper  = this.el.querySelector<HTMLElement>('.x-form__field-errors') || undefined;\n    this.inputs         = config.inputs;\n    this.name           = config.name;\n    this.type           = config.type;\n\n    this.isMultiple = this.name.includes('[]');\n    this.isFile     = this.type === 'file';\n  }\n\n  get value(): FormDataEntryValue | FormDataEntryValue[] | null {\n    const data = new FormData(this.form.config.el);\n\n    return this.isMultiple ? data.getAll(this.name) : data.get(this.name);\n  }\n\n  public addError(code: string|number, msg: string, el?: HTMLElement) : void {\n    this.el.classList.add('x-form__field--error');\n\n    if (! keys(this.errors).includes('' + code)) {\n      if (! el) {\n        const $el = $().create<HTMLElement>({ content: msg }).addClass('x-form__field-error');\n        el = $el[0];\n      }\n\n      this.errors[code] = {\n        msg,\n        el\n      };\n      \n      (this.errorsWrapper || this.el).append(this.errors[code].el!);\n      nextTick(() => el!.classList.add('x-form__field-error--show'));\n    }\n  }\n\n  public removeError(code: string) : void {\n    if (keys(this.errors).includes(code)) {\n      this.errors[code].el?.remove();\n      delete this.errors[code];\n    }\n\n    if (! keys(this.errors).length) {\n      this.el.classList.remove('x-form__field--error');\n    }\n  }\n\n  public clearErrors() : void {\n    for (const error_code in this.errors) {\n      this.removeError(error_code);\n    }\n    this.el.classList.remove('x-form__field--error');\n  }\n}","import EventEmitter from '@xaro/event-emitter';\nimport $, { MicroDOM, nextTick } from '@xaro/micro-dom';\nimport { I_XaroForm, I_XaroFormInitializeConfig, I_XaroFormConstructorConfig, I_XaroFormConfig, I_Field, InputElement, XaroFormPlugin  } from './types';\nimport Validator from './Validator';\nimport Field from './Field';\nimport { camelToSnake, difference, intersection, keys, snakeToCamel } from './helpers';\n\nexport default class XaroForm implements I_XaroForm {\n  public static EventEmitter  = EventEmitter;\n  public static MicroDOM      = MicroDOM;\n\n  // object with all registered plugins\n  public static plugins: { [key: string]: XaroFormPlugin } = {};\n\n  // all forms instances\n  public static instances: { [key: string]: XaroForm[] } = {};\n\n  // forms amount\n  public static numbers: number = 0;\n  \n  // common forms config\n  public static config: {\n    lexicon: { [key: string]: string };\n    [key: string]: any;\n  };\n\n  // custom validators\n  public static customValidators: { [key: string]: Function } = {};\n\n  // event emitter\n  public emitter: EventEmitter;\n\n  // current form config\n  public config: I_XaroFormConfig;\n\n  // fields elements with inputs\n  public fields: { [key: string]: I_Field } = {};\n\n  // form buttons element (submit/reset/etc)\n  public btns: { [key: string]: Array<HTMLButtonElement | HTMLInputElement> } = {};\n\n  // other errors wrapper\n  public errorsEl?: HTMLElement;\n\n  // other errors object\n  public errors: {\n    [field_key: string]: {\n      [code: string]: {\n        msg: string,\n        el?: HTMLElement\n      }\n    }\n  } = {};\n\n  // plugins for current instance\n  public plugins: {\n    list:   string[],\n    config: {}\n  } = {\n    list:   [],\n    config: {}\n  };\n\n  /**\n   * Registers plugin for XaroForm\n   * @param name string Plugin's name\n   * @param plugin XaroFormPlugin Plugin's object\n   */\n  public static addPlugin(name: string, plugin: XaroFormPlugin): void {\n    XaroForm.plugins[name] = plugin;\n  }\n\n  /**\n   * Removes plugin by name\n   * @param name string Plugin's name\n   */\n  public static removePlugin(name: string): void {\n    delete XaroForm.plugins[name];\n  }\n\n  /**\n   * Initialize all forms from config\n   * @param config I_XaroFormInitializeConfig\n   */\n  public static initialize(config: I_XaroFormInitializeConfig): void {\n    XaroForm.config = config.common;\n\n    if ((window as any).XaroFormPlugins) {\n      for (const key in (window as any).XaroFormPlugins) {\n        XaroForm.addPlugin(key, (window as any).XaroFormPlugins[key]);\n      }\n    }\n\n    for (const key in config.forms) {\n      XaroForm.instances[key] = [];\n      const forms: MicroDOM<HTMLFormElement> = $(`${config.forms[key]['form_selector']}[data-form-key=\"${key}\"]`);\n      for (const el of forms) {\n        XaroForm.instances[key].push(new XaroForm(Object.assign({}, config.forms[key], {\n          el,\n          on: (window as any).XaroFormEvents || {}\n        })));\n        XaroForm.numbers++;\n      }\n    }\n\n    // console.log(config, XaroForm.instances);\n  }\n\n  constructor(config: I_XaroFormConstructorConfig) {\n    this.emitter = new EventEmitter(config.on);\n    this.config = config;\n\n    // Fields\n    for (const el of $(this.config.el).get<HTMLElement>('.x-form__field')) {\n      const inputs: MicroDOM<InputElement> = $(el).get<InputElement>('.x-form__input');\n\n      if (! inputs.length) {\n        throw new Error(\"Field element has not contains input element/s\");\n      }\n\n      const name: string = inputs[0].name;\n\n      if (! name) {\n        throw new Error(\"Name of input element does not exists\");\n      }\n\n      this.fields[name] = new Field({\n        form: this,\n        el,\n        inputs,\n        name,\n        type: inputs[0].type,\n      });\n    }\n\n    // Buttons (submit/reset/etc)\n    let btn_i = 0;\n    for (const btn of $(this.config.el).get<HTMLButtonElement|HTMLInputElement>('.x-form__btn')) {\n      const type: string|null = btn.getAttribute('type');\n      if (type) {\n        if (type in this.btns) {\n          this.btns[type].push(btn);\n        } else {\n          this.btns[type] = [ btn ];\n        }\n      } else {\n        this.btns['undefined_' + btn_i] = [ btn ];\n        btn_i++;\n      }\n    }\n    this.lockBtns();\n\n    // Common errors wrapper el\n    const errorsEl = $(this.config.el).get<HTMLElement>('.x-form__errors');\n    this.errorsEl = errorsEl.length ? errorsEl[0] : undefined;\n\n    // Submit listener\n    this.config.el.addEventListener('submit', e => {\n      e.preventDefault();\n\n      this.submit();\n\n      return false;\n    });\n\n\n    // plugins\n    const pluginKeys = keys(XaroForm.plugins);\n    if (this.config.plugins) {\n      let plugins: string[] = [];\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        if (pluginKeys.includes(this.config.plugins[i])) {\n          plugins.push(this.config.plugins[i]);\n        }\n      }\n      this.plugins.list = plugins;\n    }\n\n    this.runPlugins('init', this);\n    this.emitter.emit('init', this);\n  }\n\n  public runPlugins(method: string, ...args): void {\n    for (const key of this.plugins.list) {\n      if (method in XaroForm.plugins[key]) {\n        XaroForm.plugins[key][method](this, ...args);\n      }\n    }\n  }\n\n\n  public validate() {\n    const rules = this.parseRules();\n\n    // codes\n    let codes: { [key: string]: { [method: string]: (string | number | boolean | undefined) } } = {};\n    for (const field in rules) {\n      for (const rule of rules[field]) {\n        const result = Validator[rule.method](this.fields[field], rule.value);\n        if (! result) {\n          if (! codes[field]) {\n            codes[field] = {};\n          }\n          codes[field][rule.method] = rule.value;\n        }\n      }\n    }\n\n    // get text error\n    let errors: { [key: string]: { [code: string]: string } } = {};\n    for (const field in codes) {\n      for (const code in codes[field]) {\n        const _code = camelToSnake(code);\n        const msg = this.config.lexicon && this.config.lexicon[_code]\n          ? this.config.lexicon.errors[_code]\n          : XaroForm.config.lexicon.errors[_code];\n\n        if (typeof errors[field] === 'undefined') {\n          errors[field] = {};\n        }\n\n        errors[field][_code] = msg.replace('$', codes[field][code] as string || '');\n      }\n    }\n\n    return {\n      success: !keys(errors).length,\n      errors,\n    };\n  }\n\n  protected parseRules(): Object {\n    const validateProperty: string[] = this.config.client_validate.split(',');\n\n    let fields: { [key: string]: string[] } = {};\n    for (const item of validateProperty) {\n      let _item: string[] = item.split(':');\n      if (item.length) {\n        fields[_item.shift()!] = _item;\n      }\n    }\n\n    let fieldValidators: {\n      [key: string]: {\n        method: string,\n        value?: string | number | boolean\n      }[]\n    } = {};\n    for (const key in fields) {\n      for (const v of fields[key]) {\n        const _v: string[] = v.split('=');\n\n        // if (tmpValidatorMethods.indexOf(_v[0]) === -1) {\n        //   continue;\n        // }\n\n        if (typeof Validator[_v[0]] !== 'function') {\n          continue;\n        }\n\n        if (! Array.isArray(fieldValidators[key])) {\n          fieldValidators[key] = [];\n        }\n\n        fieldValidators[key].push({\n          method: _v.shift()!,\n          value:  _v.length ? _v[0].replace(/\\^+|\\^+/g, '') : undefined\n        })\n      }\n    }\n\n    return fieldValidators;\n  }\n\n  submit(): void {\n    this.lockBtns();\n\n    this.runPlugins('beforeSubmit', this);\n    this.emitter.emit('beforeSubmit', this);\n\n    const validator = this.validate();\n    \n    // clear fields errors\n    for (const field_key in this.fields) {\n      this.fields[field_key].clearErrors();\n    }\n\n    // clear other errors\n    this.clearErrors();\n\n    if (! validator.success) {\n      for (const field_key in validator.errors) {\n        for (const error_code in validator.errors[field_key]) {\n          this.fields[field_key].addError(error_code, validator.errors[field_key][error_code]);\n        }\n      }\n\n      this.unlockBtns();\n      // this, success, errors, side (client/server)\n      this.runPlugins('afterSubmit', this, validator.success, validator.errors, 'client');\n      this.emitter.emit('afterSubmit', this, validator.success, validator.errors, 'client');\n      return;\n    }\n\n    fetch(this.config['action_url'], {\n      method: 'POST',\n      // headers: {\n      //   'Content-Type': this.config.el.getAttribute('enctype')\n      // },\n      body: new FormData(this.config.el)\n    })\n    .then(response => {\n      // console.log(response.text());\n      return response.json();\n    })\n    .then(data => {\n      if (! data.success) {\n        // arrays of keys\n        const fields        = keys(this.fields);\n        const dataFields    = keys(data.errors);\n\n        // other errors\n        for (const key of difference(fields, dataFields)) {\n          for (const code in data.errors[key]) {\n            this.addError(key, code, data.errors[key][code]);\n          }\n        }\n\n        // fields errors\n        for (const key of intersection(dataFields, fields)) {\n          for (const code in data.errors[key]) {\n            this.fields[key].addError(code, data.errors[key][code]);\n          }\n        }\n      }\n      \n      this.runPlugins('afterSubmit', this, data.success, data.errors, 'server');\n      this.emitter.emit('afterSubmit', this, data.success, data.errors, 'server');\n    });\n  }\n\n  addError(key: string, code: string, msg: string, el?: HTMLElement): void {\n    if (keys(this.errors).includes(key) && keys(this.errors[key]).includes(code)) {\n      return;\n    }\n\n    this.errors[key] = this.errors[key] || {};\n    \n    if (this.errorsEl) {\n      if (! el) {\n        const $el = $().create<HTMLElement>({ content: msg }).addClass('x-form__error').attr({\n          'data-field-key':   key,\n          'data-error-code':  code,\n        });\n        \n        this.errorsEl.append($el[0]);\n        \n        nextTick(() => $el.addClass('x-form__error--show'));\n\n        el = $el[0];\n      }\n    }\n\n    this.errors[key][code] = {\n      msg,\n      el\n    }\n  }\n\n  removeError(key: string, code: string): void {\n    if (! keys(this.errors).includes(key) &&\n        ! keys(this.errors[key]).includes(code)) {\n      return;\n    }\n\n    this.errors[key][code].el?.remove();\n    delete this.errors[key][code];\n  }\n\n  clearErrors(): void {\n    // fields errors\n    for (const key in this.fields) {\n      this.fields[key].clearErrors();\n    }\n\n    // other errors\n    for (const key in this.errors) {\n      for (const code in this.errors[key]) {\n        this.removeError(key, code);\n      }\n    }\n  }\n\n  changeDisabledAttr(value: boolean): void {\n    for (const key in this.btns) {\n      for (const btn of this.btns[key]) {\n        btn.disabled = value;\n      }\n    }\n  }\n\n  lockBtns(): void {\n    this.changeDisabledAttr(true);\n  }\n\n  unlockBtns(): void {\n    this.changeDisabledAttr(false);\n  }\n}"],"names":["Validator","[object Object]","field","isMultiple","value","length","isFile","input","inputs","match","confirm_key","form","fields","keys","obj","Object","Field","config","this","el","errorsWrapper","querySelector","undefined","name","type","includes","data","FormData","getAll","get","code","msg","classList","add","errors","$el","$","create","content","addClass","append","nextTick","remove","error_code","removeError","XaroForm","list","emitter","EventEmitter","on","Error","btn_i","btn","getAttribute","btns","push","lockBtns","errorsEl","addEventListener","e","preventDefault","submit","pluginKeys","plugins","i","runPlugins","emit","plugin","common","window","XaroFormPlugins","key","addPlugin","forms","instances","assign","XaroFormEvents","numbers","method","args","rules","parseRules","codes","rule","_code","replace","char","toLowerCase","lexicon","success","validateProperty","client_validate","split","item","_item","shift","fieldValidators","v","_v","Array","isArray","validator","validate","field_key","clearErrors","addError","unlockBtns","fetch","body","then","response","json","dataFields","target","compare","filter","x","difference","first","second","intersection","attr","data-field-key","data-error-code","disabled","changeDisabledAttr","MicroDOM"],"mappings":"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"}