{"version":3,"file":"xaroform.0.0.1-pl.js","sources":["../src/Validator.ts","../src/helpers.ts","../src/Field.ts","../src/XaroForm.ts"],"sourcesContent":["import { I_Field } from \"./types\";\n\nexport default class Validator {\n  public static required(field: I_Field) : boolean {\n    if (field.isMultiple) {\n      return !!(field.value as FormDataEntryValue[]).length;\n    } else if (field.isFile) {\n      for (const input of field.inputs) {\n        if (input.value !== '') {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return field.value !== null && field.value !== '';\n    // return field.isMultiple ? !!(field.value as FormDataEntryValue[]).length : field.value !== '';\n  }\n\n  public static minLength(field: I_Field, value: string) : boolean {\n    return (field.value as string).length >= +value;\n  }\n\n  public static maxLength(field: I_Field, value: string) : boolean {\n    return (field.value as string).length <= +value;\n  }\n\n  public static email(field: I_Field) : boolean {\n    return !!(field.value as string).match(/^[a-zA-Zа-яА-Яё\\d][a-zA-Zа-яА-ЯёЁ\\d\\.\\-_]*[a-zA-Zа-яА-ЯёЁ\\d]\\@[a-zA-Zа-яА-ЯёЁ\\d]([a-zA-Zа-яА-ЯёЁ\\d\\-]|\\.)+[a-zA-Zа-яА-ЯёЁ\\d]{2,}$/);\n  }\n\n  public static passwordConfirm(field: I_Field, confirm_key: string) : boolean {\n    return field.value === field.form.fields[confirm_key].value;\n  }\n\n  // public static file\n}","export const microtime = (getAsFloat: boolean = true) => {\n  let s, now, multiplier;\n\n  if (typeof performance !== 'undefined' && performance.now) {\n    now = (performance.now() + performance.timing.navigationStart) / 1000;\n    multiplier = 1e6; // 1,000,000 for microseconds\n  } else {\n    now = (Date.now ? Date.now() : new Date().getTime()) / 1000;\n    multiplier = 1e3; // 1,000\n  }\n\n  // Getting microtime as a float is easy\n  if (getAsFloat) {\n    return now;\n  }\n\n  // Dirty trick to only get the integer part\n  s = now | 0;\n\n  return (Math.round((now - s) * multiplier ) / multiplier ) + ' ' + s;\n}\n\n/**\n * Convert string with camelCase to snake_case\n * @param str string\n * @returns string\n * @example camelToSnake('isNumber') => 'is_number'\n */\nexport const camelToSnake = (str: string) => str.replace(/[A-Z]/g, (char: string) => '_' + char.toLowerCase());\n\n/**\n * Convert string with snake_case to camelCase\n * @param str string\n * @returns string\n * @example snakeToCamel('is_number') => 'isNumber'\n */\nexport const snakeToCamel = (str: string) => str.replace(/_[a-z]/g, (char: string) => char.toUpperCase().replace('_', ''));\n\n/**\n * Returns the intersection of two arrays.\n * @example intersection([ 1, 3, 5 ], [ 1, 5, 7 ]) => [ 1, 5 ]\n */\nexport const intersection = (first: any[], second: any[]) =>\n  first.filter((x: any) => second.includes(x));\n\n/**\n * Returns the intersection of multiple arrays.\n * @param arrs any[][]\n * @returns any[]\n * @example intersectionMultiple([ 1, 3, 5 ]) => [ 1, 3, 5 ]\n * @example intersectionMultiple([ 1, 3, 5 ], [ 1, 5, 7 ]) => [ 1, 5 ]\n * @example intersectionMultiple([ 1, 3, 5 ], [ 1, 5, 7 ], [ 1, 7, 11 ]) => [ 1 ]\n */\nexport const intersectionMultiple = (...arrs: any[][]) => {\n  if (!arrs.length) {\n    return [];\n  }\n\n  if (arrs.length === 1) {\n    return arrs[0];\n  }\n\n  let result!: any[];\n\n  for (let i = 1; i < arrs.length; i++) {\n    result = arrs[i-1].filter(x => arrs[i].includes(x));\n  }\n\n  return result;\n}\n\n// console.log(intersectionMultiple(\n//   [ 1, 3, 5, 7, 9, 11, 13],\n//   [ 2, 3, 7, 11, 15],\n//   // [ 5, 7, 10, 11, 17 ],\n//   // [ 4, 6, 7, 11 ]\n// ));\n/**\n * Returns the difference between the second array and the first\n * @example difference([ 1, 3, 5 ], [ 1, 5, 9 ]) => [ 3 ];\n * @example difference([ 1, 5, 9 ], [ 1, 3, 5 ]) => [ 9 ];\n */\nexport const difference = (target: any[], compare: any[]) =>\n  compare.filter((x: any) => !target.includes(x));\n\n/**\n * Returns the difference of two arrays.\n * @example difference([ 1, 3, 5 ], [ 1, 5, 9 ]) => [ 3, 9 ];\n */\nexport const differenceBoth = (first: any[], second: any[]) =>\n  first.filter((x: any) => !second.includes(x))\n  .concat(second.filter((x: any) => !first.includes(x)));\n\n/**\n * Alias for Object.keys()\n * @param obj Object\n * @returns string[]\n */\nexport const keys: (obj: {}) => string[] = obj => Object.keys(obj);","import { I_Field, I_FieldConstructorConfig, I_XaroForm, I_Error, InputElement } from \"./types\";\nimport $, { MicroDOM, nextTick } from \"@xaro/micro-dom\";\nimport { keys } from \"./helpers\";\n\nexport default class Field implements I_Field {\n  form:         I_XaroForm;\n  el:           HTMLElement;\n  inputs:       MicroDOM<InputElement>;\n  subInputs?:   MicroDOM<HTMLOptionElement>;\n  errors:       {\n    [code: string]: {\n      msg: string;\n      el?: HTMLElement;\n    }\n  } = {};\n  type:         string;\n  name:         string;\n  isMultiple:   boolean;\n  isFile:       boolean;\n\n  constructor(config: I_FieldConstructorConfig) {\n    this.form       = config.form;\n    this.el         = config.el;\n    this.inputs     = config.inputs;\n    this.name       = config.name;\n    this.type       = config.type;\n\n    this.isMultiple = this.name.includes('[]');\n    this.isFile     = this.type === 'file';\n  }\n\n  get value(): FormDataEntryValue | FormDataEntryValue[] | null {\n    const data = new FormData(this.form.config.el);\n\n    return this.isMultiple ? data.getAll(this.name) : data.get(this.name);\n  }\n\n  public addError(code: string|number, msg: string, el?: HTMLElement) : void {\n    this.el.classList.add('x-form__field--error');\n\n    if (! keys(this.errors).includes(code + '')) {\n      if (! el) {\n        const $el = $().create<HTMLElement>({ content: msg }).addClass('x-form__field-error');\n        el = $el[0];\n      }\n\n      this.errors[code] = {\n        msg,\n        el\n      };\n      \n      this.el.append(this.errors[code].el!);\n      nextTick(() => el!.classList.add('x-form__field-error--show'));\n    }\n  }\n\n  public removeError(code: string) : void {\n    if (keys(this.errors).includes(code)) {\n      this.errors[code].el?.remove();\n      delete this.errors[code];\n    }\n\n    if (! keys(this.errors).length) {\n      this.el.classList.remove('x-form__field--error');\n    }\n  }\n\n  public clearErrors() : void {\n    for (const error_code in this.errors) {\n      this.removeError(error_code);\n    }\n    this.el.classList.remove('x-form__field--error');\n  }\n}","import EventEmitter from '@xaro/event-emitter';\nimport $, { MicroDOM, nextTick } from '@xaro/micro-dom';\nimport { I_XaroForm, I_XaroFormInitializeConfig, I_XaroFormConstructorConfig, I_XaroFormConfig, I_Field, InputElement, XaroFormPlugin  } from './types';\nimport Validator from './Validator';\nimport Field from './Field';\nimport { camelToSnake, difference, intersection, keys, snakeToCamel } from './helpers';\n\nexport default class XaroForm implements I_XaroForm {\n  public static EventEmitter  = EventEmitter;\n  public static MicroDOM      = MicroDOM;\n\n  // object with all registered plugins\n  public static plugins: { [key: string]: XaroFormPlugin } = {};\n\n  // all forms instances\n  public static instances: { [key: string]: XaroForm[] } = {};\n\n  // forms amount\n  public static numbers: number = 0;\n  \n  // common forms config\n  public static config: {\n    lexicon: { [key: string]: string };\n    [key: string]: any;\n  };\n\n  // custom validators\n  public static customValidators: { [key: string]: Function } = {};\n\n  // event emitter\n  public emitter: EventEmitter;\n\n  // current form config\n  public config: I_XaroFormConfig;\n\n  // fields elements with inputs\n  public fields: { [key: string]: I_Field } = {};\n\n  // form buttons element (submit/reset/etc)\n  public btns: { [key: string]: Array<HTMLButtonElement | HTMLInputElement> } = {};\n\n  // other errors wrapper\n  public errorsEl?: HTMLElement;\n\n  // other errors object\n  public errors: {\n    [field_key: string]: {\n      [code: string]: {\n        msg: string,\n        el?: HTMLElement\n      }\n    }\n  } = {};\n\n  // plugins for current instance\n  public plugins: {\n    list:   string[],\n    config: {}\n  } = {\n    list:   [],\n    config: {}\n  };\n\n  /**\n   * Registers plugin for XaroForm\n   * @param name string Plugin's name\n   * @param plugin XaroFormPlugin Plugin's object\n   */\n  public static addPlugin(name: string, plugin: XaroFormPlugin): void {\n    XaroForm.plugins[name] = plugin;\n  }\n\n  /**\n   * Removes plugin by name\n   * @param name string Plugin's name\n   */\n  public static removePlugin(name: string): void {\n    delete XaroForm.plugins[name];\n  }\n\n  /**\n   * Initialize all forms from config\n   * @param config I_XaroFormInitializeConfig\n   */\n  public static initialize(config: I_XaroFormInitializeConfig): void {\n    XaroForm.config = config.common;\n\n    if ((window as any).XaroFormPlugins) {\n      for (const key in (window as any).XaroFormPlugins) {\n        XaroForm.addPlugin(key, (window as any).XaroFormPlugins[key]);\n      }\n    }\n\n    for (const key in config.forms) {\n      XaroForm.instances[key] = [];\n      const forms: MicroDOM<HTMLFormElement> = $(`${config.forms[key]['form_selector']}[data-form-key=\"${key}\"]`);\n      for (const el of forms) {\n        XaroForm.instances[key].push(new XaroForm(Object.assign({}, config.forms[key], {\n          el,\n          on: (window as any).XaroFormEvents || {}\n        })));\n        XaroForm.numbers++;\n      }\n    }\n\n    // console.log(config, XaroForm.instances);\n  }\n\n  constructor(config: I_XaroFormConstructorConfig) {\n    this.emitter = new EventEmitter(config.on);\n    this.config = config;\n\n    // Fields\n    for (const el of $(this.config.el).get<HTMLElement>('.x-form__field')) {\n      const inputs: MicroDOM<InputElement> = $(el).get<InputElement>('.x-form__input');\n\n      if (! inputs.length) {\n        throw new Error(\"Field element has not contains input element/s\");\n      }\n\n      const name: string = inputs[0].name;\n\n      if (! name) {\n        throw new Error(\"Name of input element does not exists\");\n      }\n\n      this.fields[name] = new Field({\n        form: this,\n        el,\n        inputs,\n        name,\n        type: inputs[0].type,\n      });\n    }\n\n    // Buttons (submit/reset/etc)\n    let btn_i = 0;\n    for (const btn of $(this.config.el).get<HTMLButtonElement|HTMLInputElement>('.x-form__btn')) {\n      const type: string|null = btn.getAttribute('type');\n      if (type) {\n        if (type in this.btns) {\n          this.btns[type].push(btn);\n        } else {\n          this.btns[type] = [ btn ];\n        }\n      } else {\n        this.btns['undefined_' + btn_i] = [ btn ];\n        btn_i++;\n      }\n    }\n    this.lockBtns();\n\n    // Common errors wrapper el\n    const errorsEl = $(this.config.el).get<HTMLElement>('.x-form__errors');\n    this.errorsEl = errorsEl.length ? errorsEl[0] : undefined;\n\n    // Submit listener\n    this.config.el.addEventListener('submit', e => {\n      e.preventDefault();\n\n      this.submit();\n\n      return false;\n    });\n\n\n    // plugins\n    const pluginKeys = keys(XaroForm.plugins);\n    if (this.config.plugins) {\n      let plugins: string[] = [];\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        if (pluginKeys.includes(this.config.plugins[i])) {\n          plugins.push(this.config.plugins[i]);\n        }\n      }\n      this.plugins.list = plugins;\n    }\n\n    this.runPlugins('init', this);\n    this.emitter.emit('init', this);\n  }\n\n  public runPlugins(method: string, ...args): void {\n    for (const key of this.plugins.list) {\n      if (method in XaroForm.plugins[key]) {\n        XaroForm.plugins[key][method](this, ...args);\n      }\n    }\n  }\n\n\n  public validate() {\n    const rules = this.parseRules();\n\n    // codes\n    let codes: { [key: string]: { [method: string]: (string | number | boolean | undefined) } } = {};\n    for (const field in rules) {\n      for (const rule of rules[field]) {\n        const result = Validator[rule.method](this.fields[field], rule.value);\n        if (! result) {\n          if (! codes[field]) {\n            codes[field] = {};\n          }\n          codes[field][rule.method] = rule.value;\n        }\n      }\n    }\n\n    // get text error\n    let errors: { [key: string]: { [code: string]: string } } = {};\n    for (const field in codes) {\n      for (const code in codes[field]) {\n        const _code = camelToSnake(code);\n        const msg = this.config.lexicon && this.config.lexicon[_code]\n          ? this.config.lexicon.errors[_code]\n          : XaroForm.config.lexicon.errors[_code];\n\n        if (typeof errors[field] === 'undefined') {\n          errors[field] = {};\n        }\n\n        errors[field][_code] = msg.replace('$', codes[field][code] as string || '');\n      }\n    }\n\n    return {\n      success: !keys(errors).length,\n      errors,\n    };\n  }\n\n  protected parseRules(): Object {\n    const validateProperty: string[] = this.config.client_validate.split(',');\n\n    let fields: { [key: string]: string[] } = {};\n    for (const item of validateProperty) {\n      let _item: string[] = item.split(':');\n      if (item.length) {\n        fields[_item.shift()!] = _item;\n      }\n    }\n\n    let fieldValidators: {\n      [key: string]: {\n        method: string,\n        value?: string | number | boolean\n      }[]\n    } = {};\n    for (const key in fields) {\n      for (const v of fields[key]) {\n        const _v: string[] = v.split('=');\n\n        // if (tmpValidatorMethods.indexOf(_v[0]) === -1) {\n        //   continue;\n        // }\n\n        if (typeof Validator[_v[0]] !== 'function') {\n          continue;\n        }\n\n        if (! Array.isArray(fieldValidators[key])) {\n          fieldValidators[key] = [];\n        }\n\n        fieldValidators[key].push({\n          method: _v.shift()!,\n          value:  _v.length ? _v[0].replace(/\\^+|\\^+/g, '') : undefined\n        })\n      }\n    }\n\n    return fieldValidators;\n  }\n\n  submit(): void {\n    this.lockBtns();\n\n    this.runPlugins('beforeSubmit', this);\n    this.emitter.emit('beforeSubmit', this);\n\n    const validator = this.validate();\n    \n    // clear fields errors\n    for (const field_key in this.fields) {\n      this.fields[field_key].clearErrors();\n    }\n\n    // clear other errors\n    this.clearErrors();\n\n    if (! validator.success) {\n      for (const field_key in validator.errors) {\n        for (const error_code in validator.errors[field_key]) {\n          this.fields[field_key].addError(error_code, validator.errors[field_key][error_code]);\n        }\n      }\n\n      this.unlockBtns();\n      // this, success, errors, side (client/server)\n      this.runPlugins('afterSubmit', this, validator.success, validator.errors, 'client');\n      this.emitter.emit('afterSubmit', this, validator.success, validator.errors, 'client');\n      return;\n    }\n\n    fetch(this.config['action_url'], {\n      method: 'POST',\n      // headers: {\n      //   'Content-Type': this.config.el.getAttribute('enctype')\n      // },\n      body: new FormData(this.config.el)\n    })\n    .then(response => {\n      // console.log(response.text());\n      return response.json();\n    })\n    .then(data => {\n      if (! data.success) {\n        // arrays of keys\n        const fields        = keys(this.fields);\n        const dataFields    = keys(data.errors);\n\n        // other errors\n        for (const key of difference(fields, dataFields)) {\n          for (const code in data.errors[key]) {\n            this.addError(key, code, data.errors[key][code]);\n          }\n        }\n\n        // fields errors\n        for (const key of intersection(dataFields, fields)) {\n          for (const code in data.errors[key]) {\n            this.fields[key].addError(code, data.errors[key][code]);\n          }\n        }\n      }\n      \n      this.runPlugins('afterSubmit', this, data.success, data.errors, 'server');\n      this.emitter.emit('afterSubmit', this, data.success, data.errors, 'server');\n    });\n  }\n\n  addError(key: string, code: string, msg: string, el?: HTMLElement): void {\n    if (keys(this.errors).includes(key) && keys(this.errors[key]).includes(code)) {\n      return;\n    }\n\n    this.errors[key] = this.errors[key] || {};\n    \n    if (this.errorsEl) {\n      if (! el) {\n        const $el = $().create<HTMLElement>({ content: msg }).addClass('x-form__error').attr({\n          'data-field-key':   key,\n          'data-error-code':  code,\n        });\n        \n        this.errorsEl.append($el[0]);\n        \n        nextTick(() => $el.addClass('x-form__error--show'));\n\n        el = $el[0];\n      }\n    }\n\n    this.errors[key][code] = {\n      msg,\n      el\n    }\n  }\n\n  removeError(key: string, code: string): void {\n    if (! keys(this.errors).includes(key) &&\n        ! keys(this.errors[key]).includes(code)) {\n      return;\n    }\n\n    this.errors[key][code].el?.remove();\n    delete this.errors[key][code];\n  }\n\n  clearErrors(): void {\n    // fields errors\n    for (const key in this.fields) {\n      this.fields[key].clearErrors();\n    }\n\n    // other errors\n    for (const key in this.errors) {\n      for (const code in this.errors[key]) {\n        this.removeError(key, code);\n      }\n    }\n  }\n\n  changeDisabledAttr(value: boolean): void {\n    for (const key in this.btns) {\n      for (const btn of this.btns[key]) {\n        btn.disabled = value;\n      }\n    }\n  }\n\n  lockBtns(): void {\n    this.changeDisabledAttr(true);\n  }\n\n  unlockBtns(): void {\n    this.changeDisabledAttr(false);\n  }\n}"],"names":["Validator","[object Object]","field","isMultiple","value","length","isFile","input","inputs","match","confirm_key","form","fields","keys","obj","Object","Field","config","this","el","name","type","includes","data","FormData","getAll","get","code","msg","classList","add","errors","$el","$","create","content","addClass","append","nextTick","remove","error_code","removeError","XaroForm","list","emitter","EventEmitter","on","Error","btn_i","btn","getAttribute","btns","push","lockBtns","errorsEl","undefined","addEventListener","e","preventDefault","submit","pluginKeys","plugins","i","runPlugins","emit","plugin","common","window","XaroFormPlugins","key","addPlugin","forms","instances","assign","XaroFormEvents","numbers","method","args","rules","parseRules","codes","rule","_code","replace","char","toLowerCase","lexicon","success","validateProperty","client_validate","split","item","_item","shift","fieldValidators","v","_v","Array","isArray","validator","validate","field_key","clearErrors","addError","unlockBtns","fetch","body","then","response","json","dataFields","target","compare","filter","x","difference","first","second","intersection","attr","data-field-key","data-error-code","disabled","changeDisabledAttr","MicroDOM"],"mappings":"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"}